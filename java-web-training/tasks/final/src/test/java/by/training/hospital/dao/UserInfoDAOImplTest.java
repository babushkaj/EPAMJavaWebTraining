package by.training.hospital.dao;

import by.training.hospital.dto.UserInfoDTO;
import org.junit.*;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.List;

//@Ignore
@RunWith(JUnit4.class)
public class UserInfoDAOImplTest {
    private static final String DB_PROPERTY = "database";
    private static ConnectionManager connectionManager;
    private static ConnectionPool connectionPool;

    @BeforeClass
    public static void initPool() throws ConnectionPoolException {
        connectionPool = ConnectionPoolImpl.getInstance();
        connectionPool.init(DB_PROPERTY, 5);
        TransactionManager transactionManager = new TransactionManagerImpl(connectionPool);
        connectionManager = new ConnectionManagerImpl(transactionManager);
    }

    @AfterClass
    public static void destroyPool() throws ConnectionPoolException {
        connectionPool.destroy();
    }

    @Before
    public void createTable() throws SQLException {
        String createRoleTable = "CREATE TABLE user_role" +
                " (id BIGINT GENERATED BY DEFAULT AS IDENTITY(START WITH 1, INCREMENT BY 1)," +
                "  role_name VARCHAR(10) NOT NULL," +
                " PRIMARY KEY (id))";

        executeSql(createRoleTable);

        String createUserAccountTable = "CREATE TABLE user_account (" +
                "  id         BIGINT GENERATED BY DEFAULT AS IDENTITY(START WITH 1, INCREMENT BY 1)," +
                "  login      VARCHAR(25) UNIQUE  NOT NULL," +
                "  password   VARCHAR(35)         NOT NULL," +
                "  is_blocked BOOLEAN DEFAULT false NOT NULL," +
                "  role_id    BIGINT DEFAULT 2 NOT NULL," +
                "  PRIMARY KEY (id)," +
                "  FOREIGN KEY (role_id) REFERENCES user_role (id))";

        executeSql(createUserAccountTable);

        String createUserInfoTable = "CREATE TABLE user_info (" +
                "  id         BIGINT GENERATED BY DEFAULT AS IDENTITY(START WITH 1, INCREMENT BY 1)," +
                "  first_name VARCHAR(25)        NOT NULL," +
                "  last_name  VARCHAR(25)        NOT NULL," +
                "  email      VARCHAR(25) UNIQUE NOT NULL," +
                "  phone      VARCHAR(15)," +
                "  user_id    BIGINT             NOT NULL," +
                "  PRIMARY KEY (id)," +
                "  FOREIGN KEY (user_id) REFERENCES user_account (id))";

        executeSql(createUserInfoTable);

        String insertRoles = "INSERT INTO user_role (role_name)" +
                " VALUES ('ADMIN')," +
                "       ('VISITOR')," +
                "       ('DOCTOR')";

        executeSql(insertRoles);

        String insertUserAccounts = "INSERT INTO user_account (login, password, role_id)" +
                " VALUES ('Visitor1', 'd8578edf8458ce06fbc5bb76a58c5ca4', 2)," +
                "       ('Visitor2', '4e5fd8ab9c0e3e84ab141a65e36ef094', 2)," +
                "       ('Doctor1', 'bec92fe29583ad9a32a1f1b4d1df5b01', 3)";

        executeSql(insertUserAccounts);

        String insertUserInfos = "INSERT INTO user_info (first_name, last_name, email, phone, user_id) " +
                " VALUES ('Посетитель1', 'Посетитель1', 'visitor1@gmail.com', '+375291111111', 1), " +
                "        ('Посетитель2', 'Посетитель2', 'visitor2@gmail.com', '+375292222222', 2), " +
                "        ('Врач1', 'Врач1', 'doctor1@gmail.com', '+375293333333', 3)";

        executeSql(insertUserInfos);
    }

    @After
    public void deleteTables() throws SQLException {
        String dropUserInfos = "DROP TABLE user_info";
        String dropUsers = "DROP TABLE user_account";
        String dropRoles = "DROP TABLE user_role";
        executeSql(dropUserInfos);
        executeSql(dropUsers);
        executeSql(dropRoles);

    }

    private void executeSql(String sql) throws SQLException {
        Connection connection = DriverManager.getConnection("jdbc:hsqldb:mem:hospital", "sa", "");
        PreparedStatement statement = connection.prepareStatement(sql);
        statement.executeUpdate();
        statement.close();
        connection.close();
    }

    @Test
    public void shouldReturnUserInfo() throws NoConcreteEntityInDatabaseException, DAOException {
        UserInfoDAO userInfoDAO = new UserInfoDAOImpl(connectionManager);
        UserInfoDTO userInfoDTO = userInfoDAO.getById(1L);

        Assert.assertEquals(userInfoDTO.getFirstName(), "Посетитель1");
    }

    @Test
    public void shouldAddUserInfo() throws DAOException {
        UserInfoDAO userInfoDAO = new UserInfoDAOImpl(connectionManager);
        UserInfoDTO userInfoDTO = new UserInfoDTO();
        userInfoDTO.setFirstName("Посетитель3");
        userInfoDTO.setLastName("Посетитель3");
        userInfoDTO.setEmail("visitor3@mail.ru");
        userInfoDTO.setPhone("+375299999999");
        userInfoDTO.setUserId(1L);
        long newUserInfoId = userInfoDAO.create(userInfoDTO);

        Assert.assertEquals(newUserInfoId, 4);
    }

    @Test
    public void shouldUpdateUserInfo() throws NoConcreteEntityInDatabaseException, DAOException {
        UserInfoDAO userInfoDAO = new UserInfoDAOImpl(connectionManager);
        UserInfoDTO userInfoDTO = userInfoDAO.getById(1L);
        userInfoDTO.setEmail("updatedEmail@gmail.com");
        boolean result = userInfoDAO.update(userInfoDTO);
        UserInfoDTO userInfoUpdatedDTO = userInfoDAO.getById(1L);

        Assert.assertTrue(result);
        Assert.assertEquals(userInfoUpdatedDTO.getEmail(), "updatedEmail@gmail.com");
    }

    @Test
    public void shouldDeleteAddress() throws DAOException {
        UserInfoDAO userInfoDAO = new UserInfoDAOImpl(connectionManager);
        boolean result = userInfoDAO.delete(1L);
        List<UserInfoDTO> userInfos = userInfoDAO.getAll();

        Assert.assertTrue(result);
        Assert.assertEquals(userInfos.size(), 2);
    }

    @Test
    public void shouldReturnAllAddresses() throws DAOException {
        UserInfoDAO userInfoDAO = new UserInfoDAOImpl(connectionManager);
        List<UserInfoDTO> userInfos = userInfoDAO.getAll();

        Assert.assertEquals(userInfos.size(), 3);
    }

    @Test
    public void shouldReturnUserInfoByUserId() throws DAOException {
        UserInfoDAO userInfoDAO = new UserInfoDAOImpl(connectionManager);
        UserInfoDTO userInfoDTO = userInfoDAO.getUserInfoByUserId(1L);

        Assert.assertEquals(userInfoDTO.getFirstName(), "Посетитель1");
    }

    @Test
    public void shouldReturnTrue() throws DAOException {
        UserInfoDAO userInfoDAO = new UserInfoDAOImpl(connectionManager);
        boolean result = userInfoDAO.isEmailUnique("uniqueemail@mail.ru");

        Assert.assertTrue(result);
    }

    @Test
    public void shouldReturnFalse() throws DAOException {
        UserInfoDAO userInfoDAO = new UserInfoDAOImpl(connectionManager);
        boolean result = userInfoDAO.isEmailUnique("doctor1@gmail.com");

        Assert.assertFalse(result);
    }
}
