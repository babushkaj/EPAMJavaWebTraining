package by.training.hospital.dao;

import by.training.hospital.dto.AddressDTO;
import org.junit.*;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.List;

//@Ignore
@RunWith(JUnit4.class)
public class AddressDAOImplTest {

    private static final String DB_PROPERTY = "database";
    private static ConnectionManager connectionManager;
    private static ConnectionPool connectionPool;

    @BeforeClass
    public static void initPool() throws ConnectionPoolException {
        connectionPool = ConnectionPoolImpl.getInstance();
        connectionPool.init(DB_PROPERTY, 5);
        TransactionManager transactionManager = new TransactionManagerImpl(connectionPool);
        connectionManager = new ConnectionManagerImpl(transactionManager);
    }

    @Before
    public void createTable() throws SQLException {
        String createRoleTable = "CREATE TABLE user_role" +
                " (id BIGINT GENERATED BY DEFAULT AS IDENTITY(START WITH 1, INCREMENT BY 1)," +
                "  role_name VARCHAR(10) NOT NULL," +
                " PRIMARY KEY (id))";

        executeSql(createRoleTable);

        String createUserAccountTable = "CREATE TABLE user_account (" +
                "  id         BIGINT GENERATED BY DEFAULT AS IDENTITY(START WITH 1, INCREMENT BY 1)," +
                "  login      VARCHAR(25) UNIQUE  NOT NULL," +
                "  password   VARCHAR(35)         NOT NULL," +
                "  is_blocked BOOLEAN DEFAULT false NOT NULL," +
                "  role_id    BIGINT DEFAULT 2 NOT NULL," +
                "  PRIMARY KEY (id)," +
                "  FOREIGN KEY (role_id) REFERENCES user_role (id));";

        executeSql(createUserAccountTable);

        String createAddressTable = "CREATE TABLE address (" +
                "  id        BIGINT GENERATED BY DEFAULT AS IDENTITY(START WITH 1, INCREMENT BY 1)," +
                "  region    VARCHAR(25) NOT NULL," +
                "  city      VARCHAR(25) NOT NULL," +
                "  street    VARCHAR(25)," +
                "  house     VARCHAR(5)," +
                "  apartment VARCHAR(5)," +
                "  user_id   BIGINT      NOT NULL," +
                "  PRIMARY KEY (id)," +
                "  FOREIGN KEY (user_id) REFERENCES user_account (id))";

        executeSql(createAddressTable);

        String insertRoles = "INSERT INTO user_role (role_name)" +
                "VALUES ('ADMIN')," +
                "       ('VISITOR')," +
                "       ('DOCTOR')";

        executeSql(insertRoles);

        String insertUserAccounts = "INSERT INTO user_account (login, password, role_id)" +
                "VALUES ('Jay', 'd8578edf8458ce06fbc5bb76a58c5ca4', 2)," +
                "       ('Aloizy', '4e5fd8ab9c0e3e84ab141a65e36ef094', 2)," +
                "       ('Ostap', 'bec92fe29583ad9a32a1f1b4d1df5b01', 2)";

        executeSql(insertUserAccounts);

        String insertAddresses = "INSERT INTO address (region, city, street, house, apartment, user_id)\n" +
                "VALUES ('Минская', 'Солигорск', 'Шахтёров', '12а', '21', '1')," +
                "       ('Гомельская', 'Мозырь', 'Ленина', '32', '6', '2')," +
                "       ('Витебская', 'Полоцк', 'Советская', '4', '34', '3')";

        executeSql(insertAddresses);

    }

    @After
    public void deleteTables() throws SQLException {
        String dropAddresses = "DROP TABLE address";
        String dropUsers = "DROP TABLE user_account";
        String dropRoles = "DROP TABLE user_role";
        executeSql(dropAddresses);
        executeSql(dropUsers);
        executeSql(dropRoles);
    }

    @AfterClass
    public static void destroyPool() throws ConnectionPoolException {
        connectionPool.destroy();
    }

    private void executeSql(String sql) throws SQLException {
        Connection connection = DriverManager.getConnection("jdbc:hsqldb:mem:hospital", "sa", "");
        PreparedStatement statement = connection.prepareStatement(sql);
        statement.executeUpdate();
        statement.close();
        connection.close();
    }

    @Test
    public void shouldReturnAddress() throws NoConcreteEntityInDatabaseException, DAOException {
        AddressDAO addressDAO = new AddressDAOImpl(connectionManager);
        AddressDTO addressDTO = addressDAO.getById(1L);

        Assert.assertEquals(addressDTO.getApartment(), "21");
    }

    @Test
    public void shouldAddAddress() throws NoConcreteEntityInDatabaseException, DAOException {
        AddressDTO addressDTO = new AddressDTO();
        addressDTO.setRegion("TestRegion");
        addressDTO.setCity("TestCity");
        addressDTO.setStreet("TestStreet");
        addressDTO.setHouse("1t");
        addressDTO.setApartment("1t");
        addressDTO.setUserId(3L);
        AddressDAO addressDAO = new AddressDAOImpl(connectionManager);
        long newAddressId = addressDAO.create(addressDTO);

        Assert.assertEquals(newAddressId, 4);
    }

    @Test
    public void shouldUpdateAddress() throws NoConcreteEntityInDatabaseException, DAOException {
        AddressDAO addressDAO = new AddressDAOImpl(connectionManager);
        AddressDTO addressDTO = addressDAO.getById(1L);
        addressDTO.setStreet("StreetTest");
        boolean result = addressDAO.update(addressDTO);
        AddressDTO addressUpdatedDTO = addressDAO.getById(1L);

        Assert.assertTrue(result);
        Assert.assertEquals(addressUpdatedDTO.getStreet(), "StreetTest");
    }

    @Test
    public void shouldDeleteAddress() throws NoConcreteEntityInDatabaseException, DAOException {
        AddressDAO addressDAO = new AddressDAOImpl(connectionManager);
        boolean result = addressDAO.delete(1L);
        List<AddressDTO> addresses = addressDAO.getAll();

        Assert.assertTrue(result);
        Assert.assertEquals(addresses.size(), 2);
    }

    @Test
    public void shouldReturnAllAddresses() throws DAOException {
        AddressDAO addressDAO = new AddressDAOImpl(connectionManager);
        List<AddressDTO> addresses = addressDAO.getAll();

        Assert.assertEquals(addresses.size(), 3);
    }

    @Test
    public void shouldReturnAddressByUserId() throws DAOException {
        AddressDAO addressDAO = new AddressDAOImpl(connectionManager);
        AddressDTO addressDTO = addressDAO.getByUserId(1L);

        Assert.assertEquals(addressDTO.getApartment(), "21");
    }
}
